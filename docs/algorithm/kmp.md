---
title: 字符串匹配算法
lang: zh_CN
---

字符串匹配算法一般用于查找主串中是否包含模式串，若包含，则返回主串中的起始位置。有2中最常用的匹配算法，BF(Brute Force)，即暴力算法，KMP快速模式匹配算法

## BF算法

BF算法，顾名思义，没有什么太多的技巧，直接暴力循环查找，当存在匹配全部模式串即返回起始位置。
为方便起见，对主串定义变量名称为s，模式串定义为m。箭头指向为当前指针位置，方框为当前游标位置。流程如下:

![image.png](https://sorahei.com/static/upload/cef87545ce0679683fd4148418c26358.png)


起始上下的指针跟游标都在头部，此时i与j均为0，对s[i]与m[j](即s[0]与m[0]，为方便后面的说明，均使用i,j)进行比较，当匹配成功后，主串游标后移一位，而匹配串指针后移一位，对s[i+1]与m[j]进行比较。延伸可知，每次均是s[i+j]与m[j]进行比较。

![image.png](https://sorahei.com/static/upload/19eeb102d5f65c8405a60db04c3da614.png)

当匹配失败后，将主串指针右移一位，匹配串指针重置到头部。

此时的初始位置是这样:
![image.png](https://sorahei.com/static/upload/e26a7a1b6645452708c2e4d714047fa1.png)。
如图，依旧不匹配，主串的指针继续右移一位，且可以判断，往后直4位(即j=3)均能匹配:

![image.png](https://sorahei.com/static/upload/3202e0a09da16367db538ac679ded30e.png)

而当下一位不匹配的时候继续右移主串指针:

![image.png](https://sorahei.com/static/upload/89d36f73d20ecb82553a4065d62a70f4.png)

即每次匹配失败，均将主串指针右移一位，匹配串指针重置到头部，直至匹配出完整模式串或直至结尾匹配失败，代码实现如下:

```go
func BF(s, m string) int{
  pos := -1
  for i,_ := range s {
    for j,_ := range m {
      if s[i+j] != m[j] {
        break
      }
      if j == len(m) - 1 {
        pos = i
        goto res
      }
    }
  }
  res :
    return pos
}
```

## KMP算法 

看完BF算法之后，就有一些思考，比如一个主串``abcdabcde``，模式串为``abcde``,使用BF算法的话，主串匹配到s[0+4]的时候，会匹配失败，就会从s[1]开始重新匹配，但是显然s[1]到s[4]都不会匹配成功，这种匹配方式并没有利用到之前匹配到的信息，即s[0]到s[3]是匹配成功的。而人为匹配的话，当s[4]匹配失败后，并不会从s[1]重新开始匹配起，而是去寻找模式串的头部，即"a","ab","abc"等。这里主串移动的距离就不是1，拿这个举例，移动的距离为直接从s[0]到s[4]为4。那么有没有一种算法类似这种，一次移动的距离不止1呢？

当然有，这就是KMP算法。

那怎么确定匹配失败之后移动的距离呢？讲这个之前，先要将一些概念。

### 前缀和后缀

对于一个长度为l的字符串s，``s.substr(0,n),0<n<l``的返回均为s的前缀,比如``abcd``的前缀有``a``,``ab``,``abc``。
同理，这个字符串的后缀为``s.substr(n,l-n),1<n<l``的返回为s的后缀，``abcd``的后缀为``bcd``,``cd``,``d``。

>备注，substr(start,length)为截取从start开始长度为length的字符串

好了，讲明白了什么是前缀后缀之后，再说说为什么要讲这个。

仔细想想，每次模式串指针移动的时候，从头部开始而没有到尾部，是不是在匹配前缀？
那跟后缀又有什么关系呢？当然有关系。

后缀是为了匹配失败后确定移动距离的。

举个例子，你要在``ababababc``中匹配``ababc``


