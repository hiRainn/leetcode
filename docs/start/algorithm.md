---
title: 算法入门
lang: zh_CN
---

# 算法入门

## 什么是算法

什么是算法？我的理解是解决数学上问题的方法，都可以称为算法。比如 1+1=2 也算是算法。同一个问题，使用不同的算法，虽然得到的结果相同，但耗费的时间和资源肯定有所差异。比如求从1到100的和，效率低的办法是从 1+2+3+..+100 ,效率高的办法是利用 (1+100)*100/2 。显然后面的算法效率是更高的。

## 算法与程序的关系
算法是一解决某种问题的思想，是抽象的。程序则是为了实现某些目的或者算法而编写出来可以运行的代码。程序是算法的具体实现。

## 好的算法标准

好的算法必须能彻底解决这个问题（称为准确性），且根据其编写出的程序在任何情况下都不能崩溃（称为健壮性）。在满足这两点的前提下，运行的效率越高，算法也就越好。衡量算法运行标准的标准一般分为2个：
1. 时间复杂度 ，程序的运行时间。
2. 空间复杂度 ，程序运行所需内存空间的大小。

## 时间复杂度
判断一个算法所编程序运行时间的多少，并不是将程序编写出来，通过在计算机上运行所消耗的时间来度量。原因很简单，一方面，解决一个问题的算法可能有很多种，一一实现的工作量无疑是巨大的，得不偿失；另一方面，不同计算机的软、硬件环境不同，即便使用同一台计算机，不同时间段其系统环境也不相同，程序的运行时间很可能会受影响，严重时甚至会导致误判。

实际场景中，我们更喜欢用一个估值来表示算法所编程序的运行时间。所谓估值，即估计的、并不准确的值。注意，虽然估值无法准确的表示算法所编程序的运行时间，但它的得来并非凭空揣测，需要经过缜密的计算后才能得出。

也就是说，表示一个算法所编程序运行时间的多少，用的并不是准确值（事实上也无法得出），而是根据合理方法得到的预估值。

那么，如何预估一个算法所编程序的运行时间呢？很简单，先分别计算程序中每条语句的执行次数，然后用总的执行次数间接表示程序的运行时间。

```go
for i := 0 ; i < n ; i++ {    //<- 从 0 到 n，执行 n+1 次
    a++;                         //<- 从 0 到 n-1，执行 n 次
}
```
可以看到，这段程序中仅有 2 行代码，其中：
for 循环从 i 的值为 0 一直逐增至 n（注意，循环退出的时候 i 值为 n），因此 for 循环语句执行了 n+1 次； 

而循环内部仅有一条语句，a++ 从 i 的值为 0 就开始执行，i 的值每增 1 该语句就执行一次，一直到 i 的值为 n-1，因此，a++ 语句一共执行了 n 次。

因此，整段代码中所有语句共执行了 (n+1)+n 次，即 2n+1 次。数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。

```go
for i := 0 ; i < n ; i++ {           // n+1
    for j := 0 ; j < m ; j++ {       // n*(m+1)
        num++;                         // n*m
    }
}
```
计算此段程序的频度为：(n+1)+n(m+1)+n*m，简化后得 2nm+2n+1。值得一提的是，不同程序的运行时间，更多场景中比较的是在最坏条件下程序的运行时间。以上面这段程序为例，最坏条件即指的是当 n、m 都为无限大时此段程序的运行时间。

要知道，当 n、m 都无限大时，我们完全就可以认为 n==m。在此基础上，2nm+2n+1 又可以简化为 2n^2+2n+1，这就是此段程序在最坏情况下的运行时间，也就是此段程序的频度。

如果比较以上 2 段程序的运行时间，即比较 2n+1 和 2n^2+2n+1 的大小，显然当 n 无限大时，前者要远远小于后者。

思考一个问题，类似 2n+1、2n^2+2n+1 这样的频度，还可以再简化吗？答案是肯定的。

这里直接说结论
- 去掉频度表达式中，所有的加法常数式子。例如 2n^2+2n+1 简化为 2n^2+2n ；
- 如果表达式有多项含有无限大变量的式子，只保留一个拥有指数最高的变量的式子。例如 2n^2+2n 简化为 2n^2；
- 如果最高项存在系数，且不为 1，直接去掉系数。例如 2n^2 系数为 2，直接简化为 n^2 ；

## 大O表示法
得到最简频度的基础上，为了避免人们随意使用 a、b、c 等字符来表示运行时间，需要建立统一的规范。数据结构推出了大 O 记法（注意，是大写的字母 O，不是数字 0）来表示算法（程序）的运行时间。发展至今，此方法已为大多数人所采纳。

用大 O 记法表示上面 2 段程序的运行时间，则上面第一段程序的时间复杂度为 O(n)，第二段程序的时间复杂度为 O(n2)。

如下列举了常用的几种时间复杂度，以及它们之间的大小关系：
>O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n2)平方阶 < O(n3)(立方阶) < O(2n) (指数阶)

## 空间复杂度
和时间复杂度类似，一个算法的空间复杂度，也常用大 O 记法表示。

要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，例如：

- 程序代码本身所占用的存储空间；
- 程序中如果需要输入输出数据，也会占用一定的存储空间；
- 程序在运行过程中，可能还需要临时申请更多的存储空间。

空间复杂度遵循以下规则：
- 如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)；
- 如果随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示;
- 如果随着输入值 n 的增大，程序申请的临时空间成 n2 关系增长，则程序的空间复杂度用 O(n^2) 表示；
- 如果随着输入值 n 的增大，程序申请的临时空间成 n3 关系增长，则程序的空间复杂度用 O(n^3) 
- ..以上等等


以上仅仅是讲到一些算法的基本概念，具体的算法包括这些概念的实际理解，讲在后续中详细讲到
